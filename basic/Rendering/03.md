## 影响页面展示的因素以及优化策略

JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行。

渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验。

![](./images/09.png)

通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。

**缩小白屏时长**：
- 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
- 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。
- 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。如 `6:<link rel="stylesheet" type="text/css" href="foo.css" media="print" />`


script 标签异步加载：
- `sync`：在 HTML 解析完成之后执行，不会阻塞页面渲染
- `defer`：下载完成后立即执行，有可能会阻塞页面渲染


## 重排

修改元素高度、宽度等，浏览器会触发布局阶段，解析后面一系列操作，这个过程叫作**重排（Layout）**。

![](./images/10.png)

重排需要更新完整的流水线，所以开销大

引起重排的一些操作：
- 浏览器窗口大小发生变化
- 元素尺寸或位置发生变化
- 添加或者删除可见的 DOM 元素
- 内容发生变化，比如文本变化或者 图片被另一张不同大小图片替换

## 重绘


修改背景色，布局阶段不会被执行，直接进入绘制阶段，然后执行后面的一系列过程，这个过程叫做**重绘（Paint)**

![](./images/11.png)

重绘省去了布局和分层阶段，所以执行效率比重排高

## 合成

渲染引擎直接跳过了布局和绘制，只执行后面合成操作，这过程叫做**合成**。合成是在合成线程中运行的。

![](./images/12.png)

为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。

使用 CSS 的 transform 来实现的动画效果，可以避免重绘和重排，直接在**非主线程上**执行合成动画，效率非常高。

```css
.box {
  will-change: transform, opacity;
}
```

这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。

如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是不能使用太多，它占用的内存也会大大增加。

## 减少重绘、重排的方法

- 避免频繁操作样式，集中一次重写 style属性，或者使用 class 属性
- 批量修改 DOM，一次性插入节点
- 对于复杂的动画效果，使用绝对定位使其脱离文档流
- 使用 CSS 的 transform、opacity 来实现动画避免重排和重绘
- 先隐藏元素（display：none），应用修改，重新显示（display：block）

