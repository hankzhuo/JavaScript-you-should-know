# 浏览器从输入URL到页面展现的详细过程

- 用户输入url并回车
- 浏览器进程检查url，组装协议，构成完整的url
- 浏览器进程通过进程间通信（IPC）把 url 请求发送给网络进程
- 网络进程接收到 url 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
- 如果没有则，进行后面网络请求

## DNS 解析 目标IP

为了找出 DNS 记录，浏览器先会检查四个缓存。

- 浏览器缓存
- 操作系统缓存
- 路由缓存

**DNS 解析**
- 如果在以上缓存中没有找到，客户端会发起一个 DNS 请求，询问 www.163.com 的 IP 什么？并发给本地域名服务器（本地 DNS 服务器，如移动、电信、联通）
- 本地 DNS 收到请求，如果 **ISP** 上有缓存，则直接返回，否则会询问根域名服务器
- **根 DNS 服务器**收到缀是 .com，则转发给 .com 顶级 DNS 服务器
- **顶级 DNS 服务器**收到请求，则会发给权威 DNS 服务器处理
- **权威 DNS 服务器**处理请求（内部负载均衡），解析 IP 地址，发给本地 DNS
- 本地 DNS 将 IP 地址返回客户端

## HTTP 请求与响应

1. 得到 ip 地址，建立连接（TCP 三次握手，如果是 HTTPS，则需要 TLS 握手）后，浏览器开始打包请求，使用 HTTP 协议，添加上 HTTP 头部（应用层）
   1. 头部包含比如协商信息、User-Agent 等
2. 浏览器将应用层的包交给**传输层**，传输层包含两种协议，UDP 和 TCP。TCP 协议里有两个端口号，一个是浏览器监听的端口号，一个是服务器监听的端口号。
   1. 操作系统通过端口号来判断，它接收到的包应该交给哪个进程。
3. 浏览器将传输层的包交给**网络层**，网络层协议层是 IP，这一层会加上浏览器所在机器的 IP 和目标的 IP。
4. 操作系统判断这个 IP 是否是相同的网络号，如果是，则发送 ARP 获得目标 MAC 地址，通过交换机，直接通过 MAC 地址发给目标服务器。如果不是，则通过 ARP 协议将获取到网关 MAC 地址，然后把包发给网关，网关再将包发出去，通过路由表得到下一个路由 IP 地址（**一系列路由协议（RIP、OSPF和BGP）**），一层层找到目标 IP 的网关，该网关再查询目标 IP，通过广播方式找到目标的 MAC，从而找到目标服务器。
5. 目标服务器发现 MAC 地址能对上，发给操作系统的网络层，发现 IP 也对上了，解析 TCP 层端口号，发给响应的进程处理，进程根据 HTTP 请求头部信息，处理请求，发送一个 HTML/XML/JSON 原样返回给客户端。

## 响应数据类型处理

在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。

开始响应数据类型，URL 请求的数据类型，有时候是一个下载类型，有时候是正常的 HTML 页面，浏览器根据 Response Header 头部 `Content-Type`字段，它告诉浏览器服务器返回的响应数据体的数据类型。

如果 `Content-Type: text/html;`就是告诉服务器，服务器返回的数据是 HTML 格式。如果 Content-Type 字段的值被浏览器判断为下载类型 `application/octet-stream` ，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。

## 准备渲染进程

默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。

Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点（同协议
、同根域名）的话，那么新页面会复用父页面的渲染进程。比如：https://time.geekbang.org、https://www.geekbang.org、https://www.geekbang.org:8080

**提交文档**：
- 首先“提交文档”的消息是由**渲染进程**发出给**浏览器进程**的，这是告诉浏览器进程，它已经准备好了，可以执行解析渲染等后续操作了。
- 浏览器进程接收到当前渲染进程的“提交文档”消息后，便开始清理当前的旧文档，然后会发出“确认提交”的消息给渲染进程。同时，浏览器进程会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。
- 当渲染进程接收到“确认提交”的消息后，便开始执行解析数据、下载子资源等后续流程，并实时向浏览器进程更新最新的渲染状态。

## 渲染阶段
1. 渲染进程会将 HTML 转换为浏览器理解的 DOM 树
2. 渲染引擎将 CSS 样式转化为浏览器能理解的 styleSheets，计算出 DOM 各个元素的样式
3. DOM 树中有些标签是不需要显示的（display:none，head 标签等），所以会过滤掉后生成布局树，计算元素的布局信息
4. 对布局树进行分层，形成多个图层
5. 图层的绘制分成很多小的**绘制指令**，比如 drawRect、drawPath、restore等，然后按照顺序依次组成一个待**绘制列表**。对每个图层生成绘制列表，并将其提交给**合成线程**
6. 有些图层比较大，视口部分先绘制，合成线程将每个图层分成多个**图块**，并在**栅格化线程池中**将图块转化为**位图**
7. 所有图块都被栅格化后，合成线程发送绘制图块命令 DrawQuad 给浏览器进程
8. 浏览器进程根据 DrawQuad 指令生成页面，并显示在显示器上
